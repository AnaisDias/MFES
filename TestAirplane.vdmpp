class TestAirplane
types
		public Point :: x:int
									y:int;
values
-- TODO Define values here
instance variables
	public p : Airplane := new Airplane(0,5,5,<N>,1,20,0);
	public returnInt : int := 0;
operations
	public TestAirplane: () ==> TestAirplane
	TestAirplane () ==
	(
		return self;
	);
	
	private assertTrue: bool ==> ()
  assertTrue(cond) == return
  pre cond;
                
	public testRotate: () ==> ()
	testRotate() ==
	(
		dcl p : Airplane := new Airplane(0,7,19,<S>,1,20,0);
		returnInt := p.move();
		p.setTargetRotation(90);
		returnInt := p.move();
		returnInt := p.move();	
		assertTrue(p.getOrientation() = <E>);
		p.setTargetRotation(-180);
		returnInt := p.move();	
		returnInt := p.move();	
		returnInt := p.move();	
		returnInt := p.move();	
		assertTrue(p.getOrientation() = <W>);
	);
	
	public testFailed: () ==> ()
	testFailed() ==
	(
		dcl p : Airplane := new Airplane(0,7,19,<S>,1,20,0);
		p.setTargetRotation(180);
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		assertTrue(returnInt = 4);
	);
	
	public testSecGoal: () ==> ()
	testSecGoal() ==
	(
		dcl p : Airplane := new Airplane(0,7,19,<S>,1,20,0);
		p.setSecGoal(3,19);
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		assertTrue(returnInt = 3);
	);
	
	public testOutOfReach: () ==> ()
	testOutOfReach() ==
	(
		dcl p : Airplane := new Airplane(0,16,19,<S>,1,20,0);
		p.setTargetRotation(90);
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		returnInt := p.move();
		assertTrue(returnInt = 1);
	);
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end TestAirplane