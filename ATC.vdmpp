class ATC
types
public Point :: x:int
								y:int;
public Orientation = <N>|<NW>|<W>|<SW>|<S>|<SE>|<E>|<NE>;
values
-- TODO Define values here
instance variables

	-- Primary variables
	private airplanes: seq of Airplane;
	private runway: Runway;
	private beacons: seq of Point;
	
	--Variable to check for warnings
	private warnings: map nat to nat;
	private colisions: map nat to nat;
			
operations
	-- Constructor
	public ATC: nat * nat * Orientation * nat ==> ATC
	ATC(rx, ry, rori, c) ==
	(
		airplanes := [];
		runway := new Runway(rx, ry, rori, c);
		beacons := [];
		warnings := {|->};
		colisions := {|->};
	);
	
	
	-- Gets all planes
	public getPlanes: () ==> seq of Airplane
	getPlanes() ==
	(
		return airplanes;
	)
	post airplanes = airplanes~;
	
	-- Adds an airplane
	public addPlane: Airplane ==> ()
	addPlane(p) ==
	(
		IO`print("Trying to add a plane\n");
		IO`println(len airplanes + 1);
		IO`println(p.getPos().x);
		IO`println(p.getPos().y);
		IO`println(p.getOrientation());
		IO`println(p.getSpeed());
		IO`println(p.getGoal().x);
		IO`println(p.getGoal().y);
		(dcl pNew : Airplane := new Airplane((len airplanes + 1), p.getPos().x , p.getPos().y , p.getOrientation(), p.getSpeed(), p.getGoal().x, p.getGoal().y);
		airplanes := [pNew] ^ airplanes;)
	)
	post len airplanes = len airplanes~ +1;
	
	-- Get plane by id
	public getPlaneByID: nat ==> Airplane
	getPlaneByID(id) ==
	(
		dcl p : Airplane := new Airplane(0, -15, -15, <N> , 1, -20, 0);
		for i = 1 to len airplanes do
			if (airplanes(i).getID() = id) then 
				return airplanes(i);
				
		return p;
	);
	
	-- Removes an airplane
	public removePlane: Airplane ==> ()
	removePlane(p) ==
	(
		let l1^[p]^l2 = airplanes in airplanes := l1^l2;
	)
	pre p in set elems airplanes;
	
	-- Adds a beacon
	public addBeacon: Point ==> ()
	addBeacon(b) ==
	(
		beacons := [b] ^ beacons;
	)
	post beacons = [b] ^ beacons~;
	
	-- Removes a beacon
	public removeBeacon: Point ==> ()
	removeBeacon(b) ==
	(
		let b1^[b]^b2 = beacons in beacons := b1^b2;
	)
	pre b in set elems beacons;
	
	-- Gets all colisions
	public getColisions: () ==> map nat to nat
	getColisions() ==
	(
		return colisions;
	);
	
	-- Gets all warnings
	public getWarnings: () ==> map nat to nat
	getWarnings() ==
	(
		return warnings;
	);
	 
	-- Orders a plane to rotate clockwise
	public orderRotateCW: nat * int ==> ()
	orderRotateCW(id,r) ==
	(
		for p in airplanes do
				if( p.getID() = id) then
					p.setTargetRotation(-r);
	) 
	pre ((r rem 45) = 0 or r = 0 ) and id in set inds airplanes;
	
	-- Orders a plane to rotate counterclockwise
	public orderRotateCCW: nat * int ==> ()
	orderRotateCCW(id,r) ==
	(
		for p in airplanes do
				if( p.getID() = id) then
					p.setTargetRotation(r);
	)
	pre ((r rem 45) = 0 or r = 0 ) and id in set inds airplanes;
	
	-- Speed a plane up or down
	public orderSpeed: nat * real ==> ()
	orderSpeed(id,s) ==
	(
		for p in airplanes do
				if( p.getID() = id) then
					p.setTargetSpeed(s);
	)
	pre s > 0 and s <= 1.0 and id in set inds airplanes;
	
	-- Order a plane to go to a beacon
	public orderSecGoal: nat * Point ==> ()
	orderSecGoal(id,beacon) ==
	(
		for p in airplanes do
			if( p.getID() = id) then
				p.setSecGoal(beacon.x, beacon.y);
	)
	pre beacon in set elems beacons and id in set inds airplanes;
	
	--Checks which planes are next to each other
	public checkWarning: () ==> ()
	checkWarning() ==
	(
		warnings := {|->};
		for p1 in airplanes do
		(
			if(not p1.getLanded() and not p1.getOutOfReach()) then
			(
				for p2 in airplanes do
				(
					if(p1 <> p2 and ({p2.getID()} <: warnings) <> {p2.getID() |-> p1.getID()}
						and not p2.getLanded() and not p2.getOutOfReach()) then
					(
						dcl p1x: int := p1.getPos().x;
						dcl p1y: int := p1.getPos().y;
						dcl p2x: int := p2.getPos().x;
						dcl p2y: int := p2.getPos().y;
						
						if((p1x = (p2x + 1) or p1x =( p2x - 1)) and
							(p1y = (p2y + 1) or p1y = (p2y - 1) or p1y = p2y)) then
						(
							warnings := warnings munion {p1.getID() |-> p2.getID()};						
						)
						else if((p1x = (p2x + 1) or p1x = (p2x - 1) or p1x = p2x)) and
							(p1y = (p2y + 1) or p1y = (p2y - 1)) then
						(
							warnings := warnings munion {p1.getID() |-> p2.getID()};	
						);
					);
				);
			);
		);
	);
	
	-- Checks for colisions
	public checkColisions: () ==> ()
	checkColisions() ==
	(
		for p1 in airplanes do
		(
			if(not p1.getLanded() and not p1.getOutOfReach()) then
			(
				for p2 in airplanes do
				(
					if( p1 <> p2 and not p2.getLanded() and not p2.getOutOfReach()
						and ({p2.getID()} <: colisions) <> {p2.getID() |-> p1.getID()} ) then
					(
						dcl p1x: int := p1.getPos().x;
						dcl p1y: int := p1.getPos().y;
						dcl p2x: int := p2.getPos().x;
						dcl p2y: int := p2.getPos().y;
						
						if( p1x = p2x and p1y = p2y ) then
						(
							colisions := colisions munion {p1.getID() |-> p2.getID()};	
						);
					);
				);
			);
		);
	)
	post colisions = {|->};
	
	-- Land plane
	public landPlane: Airplane ==> ()
	landPlane(p) ==
	(
		runway.addPlane(p);
	);
	
	-- Moves every plane
	public move: () ==> int
	move() ==
	(
		dcl n : nat := 0;
		for p in airplanes do
		(
			if(not p.getLanded() and not p.getOutOfReach()) then
			(
				n := p.move();
				if( n = 1) then
				(
					if(p.getGoal().x = runway.getPos().x and p.getGoal().y = runway.getPos().y and p.getOrientation() = runway.getOrientation()) then
					(
						landPlane(p);
						p.setLanded();
					);
				)
				else if( n = 4 ) then
					return n;
			);
		);
		
		return 0;
	);
	
	-- Main function
	public main: () ==> ()
	main() ==
	(
		dcl n : nat := 0;
		n := move();
		checkColisions();
		--if(len dom colisions <> 0) then
		checkWarning();
	);
	
	
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end ATC